
// This source file was auto-generated by ClassMate++
// Created: 29 May 2015 8:42:09 am
// Copyright (c) 2015, HurleyWorks

#include "berserkpch.h"
#include "LWWrapper.h"

using namespace Eigen;
using mace::ToString;

// ctor
LWWrapper::LWWrapper()
	:global_(nullptr),
	itemInfo_(nullptr),
	sceneInfo_(nullptr),
	objectInfo_(nullptr),
	surfFuncs_(nullptr),
	runCmd_(nullptr),
	objFuncs_(nullptr),
	interfaceInfo_(nullptr),
	txFuncs_(nullptr),
	dirInfo_(nullptr),
	serverInfo_(nullptr),
	itemInfoVers_(0),
	sceneInfoVers_(0),
	objectInfoVers_(0),
	surfFuncsVers_(0),
	runCmdVers_(0),
	objFuncsVers_(0),
	interfaceInfoVers_(0),
	txtFuncsVers_(0),
	dirInfoVers_(0),
	serverInfoVers_(0),
	motionPluginCount_(-1)
{	
}

// init
bool LWWrapper::init(GlobalFunc * const g)
{
	global_ = g;
	if (!global_) return false;

	itemInfo_ = getCompatibleVersion<LWItemInfo>(LWITEMINFO_GLOBAL, global_, itemInfoVers_);
	sceneInfo_ = getCompatibleVersion<LWSceneInfo>(LWSCENEINFO_GLOBAL, global_, sceneInfoVers_);
	objectInfo_ = getCompatibleVersion<LWObjectInfo>(LWOBJECTINFO_GLOBAL, global_, objectInfoVers_);
	surfFuncs_ = getCompatibleVersion<LWSurfaceFuncs>(LWSURFACEFUNCS_GLOBAL, global_, surfFuncsVers_);
	runCmd_ = getCompatibleVersion<LWCommandFunc>(LWCOMMANDFUNC_GLOBAL, global_, runCmdVers_);
	objFuncs_ = getCompatibleVersion<LWObjectFuncs>(LWOBJECTFUNCS_GLOBAL, global_, objFuncsVers_);
	interfaceInfo_ = getCompatibleVersion<LWInterfaceInfo>(LWINTERFACEINFO_GLOBAL, global_, interfaceInfoVers_);
	txFuncs_ = getCompatibleVersion<LWTextureFuncs>(LWTEXTUREFUNCS_GLOBAL, global_, txtFuncsVers_);
	dirInfo_ = getCompatibleVersion<LWDirInfoFunc>(LWDIRINFOFUNC_GLOBAL, global_, dirInfoVers_);
	serverInfo_ = getCompatibleVersion<LWServerInfo>(LWSERVERINFO_GLOBAL, global_, serverInfoVers_);

    uintptr_t sysid = reinterpret_cast<uintptr_t> (global_ (LWSYSTEMID_GLOBAL, GFUSE_TRANSIENT));
    unsigned long application = sysid & LWSYS_TYPEBITS;

	if (application == LWSYS_LAYOUT)
	{
		if (sceneInfo_ && itemInfo_ && objectInfo_ && surfFuncs_ &&runCmd_ &&objFuncs_ &&interfaceInfo_  && txFuncs_ && dirInfo_ && serverInfo_)
		{
			const char** pluginList = serverInfo_->list(LWITEMMOTION_HCLASS);
			if (pluginList)
			{
				motionPluginCount_ = 0;
				while (pluginList[motionPluginCount_] != nullptr)
				{
					motionPluginCount_++;
				}
			}

			return true;
		}
	}
	else if (application == LWSYS_SCREAMERNET)
	{
		if (sceneInfo_ && itemInfo_ && objectInfo_ && surfFuncs_ &&runCmd_ &&objFuncs_ && txFuncs_ && dirInfo_ && serverInfo_)
		{
			return true;
		}
		else
			return false;
	}

	return false;
}

// areOtherMotionPluginsApplied
bool LWWrapper::areOtherMotionPluginsApplied(LWItemID item, const std::string & pluginName)
{
	const char** pluginList = serverInfo_->list(LWITEMMOTION_HCLASS);
	if (pluginList)
	{
		motionPluginCount_ = 0;
		while (pluginList[motionPluginCount_] != nullptr)
		{
			motionPluginCount_++;
		}
	}

	for (int i = 0; i < motionPluginCount_; i++)
	{
		const char * name = itemInfo_->server(item, LWITEMMOTION_HCLASS, i);
		if (name && pluginName != std::string(name))
			return true;
	}
	return false;
}

// applyPlugin
void LWWrapper::applyPlugin(LWItemID item, const std::string& pluginClass, const std::string& pluginName, bool addIfAlreadyAdded)
{
	// don't add if it's already applied
	const char* plugName = itemInfo_->server(item, pluginClass.c_str(), 1);
	if (!plugName || addIfAlreadyAdded)
	{
		std::string id = mace::ToString<LWItemID>(item);
		std::string addPlugin("ApplyServerByItemID ");
		addPlugin += id + " " + pluginClass + " " + pluginName;
		runCmd_(addPlugin.c_str());
	}
}

// applyPlugin
void LWWrapper::applyPlugin(const std::string& pluginClass, const std::string& pluginName)
{
	std::string cmd = "ApplyServer ";
	cmd += pluginClass + " ";
	cmd += pluginName;
	runCmd_(cmd.c_str());
}

void LWWrapper::dirtyMotion(LWItemID itemID)
{
	std::string dirtMotion("DirtyMotion  ");
	if (itemID != LWITEM_NULL)
	{
		std::string id = ToString<LWItemID>(itemID);
		dirtMotion += id;
	}
	runCmd_(dirtMotion.c_str());
}

bool LWWrapper::getItemTransform(LWItemID itemID,
						  Affine3f & transform,
						  Vector3f & scale,
						  LWTime time)
{
	bool isValid = true;

	double pos[3];
	double up[3];
	double forward[3];
	double right[3];
	double s[3];

	itemInfo_->param(itemID, LWIP_W_POSITION, time, pos);

	// world pose
	itemInfo_->param(itemID, LWIP_RIGHT, time, right);
	itemInfo_->param(itemID, LWIP_UP, time, up);
	itemInfo_->param(itemID, LWIP_FORWARD, time, forward);

	// scale
	itemInfo_->param(itemID, LWIP_SCALING, time, s);

	Vector3f translate((float)pos[0], (float)pos[1], (float)pos[2]);
	Vector3f xAxis((float)right[0], (float)right[1], (float)right[2]);
	Vector3f yAxis((float)up[0], (float)up[1], (float)up[2]);
	Vector3f zAxis((float)forward[0], (float)forward[1], (float)forward[2]);

	// extract the scale
	scale[0] = xAxis.norm();
	scale[1] = yAxis.norm();
	scale[2] = zAxis.norm();

	//LOG(DBUG) << "scale " << vecStrf(scale);

	// normalize the orientation basis vectors
	// now that we've extracted the scale
	xAxis.normalize();
	yAxis.normalize();
	zAxis.normalize();

	Matrix3f linear;
	linear.col(0) = xAxis;
	linear.col(1) = yAxis;
	linear.col(2) = zAxis;

	// test whether the rotation matrix is orthogonal
	if (!wabi::isOrthogonal(linear))
	{
		LOG(CRITICAL) << "Matrix is not orthogonal!";
		//matStr3f(linear, DBUG, __FUNCTION_NAME__);
		transform.linear() = linear;
		isValid = false;
	}
	else
	{
		transform.linear() = linear;
	}
	
	transform.translation() = translate;

	//matStr4f(transform, DBUG, __FUNCTION_NAME__);

	return (isValid && !linear.hasNaN());
}

bool LWWrapper::getItemLocalTransform(LWItemID itemID, Eigen::Affine3f & transform, Eigen::Vector3f & scale, LWTime time)
{
	bool isValid = true;

	double pos[3];
	double up[3];
	double forward[3];
	double right[3];
	double s[3];

	itemInfo_->param(itemID, LWIP_POSITION, time, pos);

	// local pose
	itemInfo_->param(itemID, LWIP_W_RIGHT, time, right);
	itemInfo_->param(itemID, LWIP_W_UP, time, up);
	itemInfo_->param(itemID, LWIP_W_FORWARD, time, forward);

	// scale
	itemInfo_->param(itemID, LWIP_SCALING, time, s);

	Vector3f translate((float)pos[0], (float)pos[1], (float)pos[2]);
	Vector3f xAxis((float)right[0], (float)right[1], (float)right[2]);
	Vector3f yAxis((float)up[0], (float)up[1], (float)up[2]);
	Vector3f zAxis((float)forward[0], (float)forward[1], (float)forward[2]);

	// extract the scale
	scale[0] = xAxis.norm();
	scale[1] = yAxis.norm();
	scale[2] = zAxis.norm();

	// normalize the orientation basis vectors
	// now that we've extracted the scale
	xAxis.normalize();
	yAxis.normalize();
	zAxis.normalize();

	Matrix3f linear;
	linear.col(0) = xAxis;
	linear.col(1) = yAxis;
	linear.col(2) = zAxis;

	// test whether the rotation matrix is orthogonal
	if (!wabi::isOrthogonal(linear))
	{
		LOG(CRITICAL) << "Matrix is not orthogonal!";
		//matStr3f(linear, DBUG, __FUNCTION_NAME__);
		transform.linear() = linear;
		isValid = false;
	}
	else
	{
		transform.linear() = linear;
	}

	transform.translation() = translate;

	return (isValid && !linear.hasNaN());
}

void LWWrapper::selectAndClear(LWItemID itemID)
{
	selectItem(itemID);
	int silent = 3;
	std::string cmd = "ClearSelected   ";
	cmd += ToString<int>(silent);
	runCmd_(cmd.c_str());
}

void LWWrapper::clone(LWItemID itemID, int count)
{
	if (itemID == LWITEM_NULL) return;
	if (count <= 0) count = 1;

	selectItem(itemID);

	std::string cmd = "Clone  ";
	cmd += ToString<int>(count);
	runCmd_(cmd.c_str());
}

void LWWrapper::scale(LWItemID itemID, const Vector3f & scale, LWTime time)
{
	selectItem(itemID);

	std::string cmd = "Scale ";
	cmd += vectorComponentsToString(scale);
	runCmd_(cmd.c_str());
}

bool LWWrapper::isMesh(LWItemID itemID)
{
	LWMeshInfo * const meshInfo = objectInfo_->meshInfo(itemID, 1);
	return meshInfo ? true : false;
}

// createMeshEditOp
void LWWrapper::createMeshEditOp(const std::string& pluginName)
{
	/// Calls the MeshEdit plugin which broadcasts a fresh MeshEditOp*
	/// via ComRing to interested listeners like LWMeshEdit 

	std::string cmd("ModCommand_" + pluginName);

	// generate the a fresh MeshEditOp by calling the MeshEdit plugin
	runCmd_(cmd.c_str());
}

void LWWrapper::createNull(const std::string & meshName)
{
	std::string cmd("AddNull ");
	cmd += meshName;
	runCmd_(cmd.c_str());
}

// createNull
LWItemID LWWrapper::createNull(const std::string & meshName,
						const std::string& pluginName)
{
	std::string cmd("AddNull ");
	cmd += meshName;
	runCmd_(cmd.c_str());

	return getItemFromName(meshName);
}

// getItemFromName
LWItemID LWWrapper::getItemFromName(const std::string & itemName)
{

	LWItemID itemID = itemInfo_->first(LWI_OBJECT, 0);
	while (itemID)
	{
		std::string meshName(itemInfo_->name(itemID));
		if (meshName == itemName)
			return itemID;

		itemID = itemInfo_->next(itemID);
	}

	itemID = itemInfo_->first(LWI_LIGHT, 0);
	while (itemID)
	{
		std::string lightName(itemInfo_->name(itemID));
		if (lightName == itemName)
			return itemID;

		itemID = itemInfo_->next(itemID);
	}

	itemID = itemInfo_->first(LWI_CAMERA, 0);
	while (itemID)
	{
		std::string cameraName(itemInfo_->name(itemID));
		if (cameraName == itemName)
			return itemID;

		itemID = itemInfo_->next(itemID);
	}

	itemID = itemInfo_->first(LWI_BONE, 0);
	while (itemID)
	{
		std::string boneName(itemInfo_->name(itemID));
		if (boneName == itemName)
			return itemID;

		itemID = itemInfo_->next(itemID);
	}

	return LWITEM_NULL;
}

// movePivot
void LWWrapper::movePivot(LWItemID itemID, const Eigen::Vector3f & newPivot)
{
	std::string selectItem("SelectItem ");
	std::string id = ToString<LWItemID>(itemID);
	selectItem += id;
	runCmd_(selectItem.c_str());

	std::string x = ToString<float>(newPivot[0]);
	std::string y = ToString<float>(newPivot[1]);
	std::string z = ToString<float>(newPivot[2]);
	std::string pos = x + " " + y + " " + z;

	std::string addPos("PivotPosition ");
	addPos += pos;
	runCmd_(addPos.c_str());
}

// transformItem
void LWWrapper::transformItem(LWItemID itemID, const Affine3f & pose, LWTime time)
{
	selectItem(itemID);

	std::string name(getItemName(itemID));

	// get Euler angles from rotation part of the transform
	// 1 = y for heading
	// 0 = x for pitch
	// 2 = z for bank
	Vector3f hpb = pose.rotation().eulerAngles(1, 0, 2);

	// LWWrapper wants degrees
	hpb *= wabi::Mathf::RAD_TO_DEG;

	std::string cmd = "Rotation ";
	cmd += vectorComponentsToString(hpb);
	runCmd_(cmd.c_str());

	cmd = "Position ";
	cmd += vectorComponentsToString(pose.translation());
	runCmd_(cmd.c_str());
}

// selectItem
void LWWrapper::selectItem(LWItemID itemID)
{
	std::string s = ToString<LWItemID>(itemID);

	std::string selectItem("SelectItem ");
	std::string id = ToString<LWItemID>(itemID);
	selectItem += id;
	runCmd_(selectItem.c_str());
}

// deselectItem
void LWWrapper::deselectItem(LWItemID itemID)
{
	std::string s = ToString<LWItemID>(itemID);

	std::string deselectItem("RemoveFromSelection  ");
	std::string id = ToString<LWItemID>(itemID);
	deselectItem += id;
	runCmd_(deselectItem.c_str());
}

// vectorComponentsToString
std::string LWWrapper::vectorComponentsToString(const Eigen::Vector3f & vec)
{
	std::ostringstream buffer;
	buffer.setf(std::ios::fixed, std::ios::floatfield);
	buffer.precision(5);
	buffer << vec[0] << " " << vec[1] << " " << vec[2];

	return buffer.str().c_str();
}

// findMasterIndex
int LWWrapper::findMasterIndex(const std::string & pluginName)
{
	int index = 1;
	while (itemInfo_->server(nullptr, LWMASTER_HCLASS, index))
	{
		std::string name(itemInfo_->server(nullptr, LWMASTER_HCLASS, index));
		if (name == pluginName)
			return index;
		++index;
	}

	return 0;
}

#if 0
// updateSelectionSet
void LWWrapper::updateSelectionSet(LWItemType selectionMode)
{
	selectedItems_.clear();

	LWItemID boneObject = nullptr;
	if (selectionMode == LWI_BONE)
		boneObject = itemInfo_->first(LWI_OBJECT, boneObject);

	LWItemID itemID = itemInfo_->first(selectionMode, boneObject);
	while (itemID)
	{
		// selected() is not part of ItemInfo interface in versions before 6
		if (itemInfoVers_ > 5 && itemInfo_->selected(itemID))
		{
			selectedItems_.insert(itemID);
		}

		itemID = itemInfo_->next(itemID);
	}
}

// getAllSceneItems
void LWWrapper::getAllSceneItems(LWItemArray & allItems)
{
	// LWI_LIGHT LWI_CAMERA LWI_OBJECT
	LWItemID itemID = itemInfo_->first(LWI_OBJECT, LWITEM_NULL);
	while (itemID)
	{
		allItems.add(itemID);
		itemID = itemInfo_->next(itemID);
	}

	itemID = itemInfo_->first(LWI_LIGHT, LWITEM_NULL);
	while (itemID)
	{
		allItems.add(itemID);
		itemID = itemInfo_->next(itemID);
	}

	itemID = itemInfo_->first(LWI_CAMERA, LWITEM_NULL);
	while (itemID)
	{
		allItems.add(itemID);
		itemID = itemInfo_->next(itemID);
	}
}

// getAllSceneItems
void LWWrapper::getAllSceneItemNames(juce::StringArray & names)
{
	// LWI_LIGHT LWI_CAMERA LWI_OBJECT
	LWItemID itemID = itemInfo_->first(LWI_OBJECT, LWITEM_NULL);
	while (itemID)
	{
		String name = getItemName(itemID);
		names.add(name);

		itemID = itemInfo_->next(itemID);
	}

	itemID = itemInfo_->first(LWI_LIGHT, LWITEM_NULL);
	while (itemID)
	{
		String name = getItemName(itemID);
		names.add(name);

		itemID = itemInfo_->next(itemID);
	}

	itemID = itemInfo_->first(LWI_CAMERA, LWITEM_NULL);
	while (itemID)
	{
		String name = getItemName(itemID);
		names.add(name);

		itemID = itemInfo_->next(itemID);
	}
}
#endif

// hasChildren
bool LWWrapper::hasChildren(LWItemID item)
{
	LWItemID child = itemInfo_->firstChild(item);

	return child != LWITEM_NULL;
}

void LWWrapper::setInteractiveMode(int state)
{
	std::string s = ToString<int>(state);
	std::string mode("InteractiveMode ");
	mode += s;

	runCmd_(mode.c_str());
}

void LWWrapper::setDynamicUpdate(int level)
{
	level = LWDYNUP_INTERACTIVE;
	std::string s = ToString<int>(level);
	std::string mode("DynamicUpdate  ");
	mode += s;

	runCmd_(mode.c_str());
}

// setLastPreviewFrame
void LWWrapper::setLastPreviewFrame(int frame)
{
	std::string cmd = "PreviewLastFrame  ";
	cmd += ToString<int>(frame);
	runCmd_(cmd.c_str());
}
